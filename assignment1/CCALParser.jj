options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
}

PARSER_BEGIN(CCALParser)
public class CCALParser {
  public static void main(String args[]) {
    CCALParser parser;
    if (args.length == 0) {
      System.out.println("Reading from standard input . . .");
      parser = new CCALParser(System.in);
    } else if (args.length == 1) {
      try {
        parser = new CCALParser(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.err.println("File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("CCAL Parser: Usage is one of:");
      System.out.println(" java CCALParser < inputfile");
      System.out.println("OR");
      System.out.println(" java CCALParser inputfile");
      return;
    }
    try {
      parser.program();
      System.out.println("CCAL Parser: CCAL program parsed successfully.");
    }
    catch (ParseException e)
    {
      System.out.println(e.getMessage());
      System.out.println("CCAL Parser:  Encountered errors during parse.");
     }
  }
}
PARSER_END(CCALParser)


/*****************************************
***** SECTION 3 - TOKEN DEFINITIONS *****
*****************************************/
TOKEN_MGR_DECLS :
{
  static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
  " "
  | "\t"
  | "\n"
  | "\r"
  | "\f"
}
SKIP : // COMMENTS
{
  < "//" (~["\r", "\n"])* >
}
SKIP : /* COMMENTS */
{
  "/*" { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
  "/*" { commentNesting++; }
  | "*/" { commentNesting--;
    if (commentNesting == 0)
    SwitchTo(DEFAULT);
  }
  | <~[]>
}
SKIP : //The string "SKIP"
{
  "SKIP"
}

TOKEN : /* Reserved words */
{
  < VAR : "var" >
  | < CONST : "const" >
  | < RETURN : "return" >
  | < INTEGER : "integer" >
  | < BOOLEAN : "boolean" >
  | < VOID : "void" >
  | < MAIN : "main" >
  | < IF : "if" >
  | < ELSE : "else" >
  | < TRUE : "true" >
  | < FALSE : "false" >
  | < WHILE : "while" >
  | < SKIP_STRING : "skip" >
}
TOKEN : /* Other reserved tokens*/
{
  < COMMA : "," >
  | < SEMIC : ";" >
  | < COLON : ":" >
  | < LBRACE : "{" >
  | < RBRACE : "}" >
  | < LPAREN : "(" >
  | < RPAREN : ")" >
}
TOKEN : /* Reserved tokens */
{
  < ASSIGN : "=" >
  | < PLUS_SIGN : "+" >
  | < MINUS_SIGN : "-" >
  | < NEGATION : "~" >
  | < OR : "||" >
  | < AND : "&&" >
  | < EQUALTO : "==" >
  | < NOTEQUALTO : "!=" >
  | < LESSTHAN : "<" >
  | < LESSTHANEQUALS : "<=" >
  | < GREATERTHAN : ">" >
  | < GREATERTHANEQUALS : ">=" >
}
TOKEN : /* Numbers and identifiers */
{
  < NUMBER : <NONZERO> (<DIGIT>)*
    | <MINUS_SIGN> <NONZERO> (<DIGIT>)* >
  | < #DIGIT : ["0" - "9"] >
  | < #NONZERO : ["1" - "9"] >
  | < ID : (<LETTER>)(<LETTER> | "_" | <DIGIT>)+ >
  | < #LETTER : ["a" - "z", "A" - "Z"] >
}
TOKEN : /* Anything not recognised so far */
{
  < OTHER : ~[] >
}
/***********************************
***** SECTION 4 - THE GRAMMAR *****
***********************************/
void program() : {}//(1)
{
  decl_list() function_list() main()
}

void decl_list() : {}//(2)
{
  decl() decl_list()
}

void decl() : {}//(3)
{
  var_decl()
  | const_decl()
}

void var_decl() : {}//(4)
{
  <VAR> <ID> <COLON> type()
}

void const_decl() : {}//(5)
{
  <CONST> <ID> type() <ASSIGN> expression()
}

void function_list() : {}//(6)
{
  (function() function_list())
}

void function() : {}//(7)
{
  type() <ID> <LPAREN> parameter_list() <RPAREN>
  <LBRACE>
    decl_list() statement_block() <RETURN> <LPAREN> (expression()) <RPAREN> <SEMIC>
  <RBRACE>
}

void type() : {}//(8)
{
  <INTEGER>
  | <BOOLEAN>
  | <VOID>
}

void parameter_list() : {}//(9)
{
  (nemp_parameter_list())
}

void nemp_parameter_list() : {}//(10)
{
  <ID> <COLON> type() [<COMMA> nemp_parameter_list()]
}

void main() : {}//(11)
{
  <MAIN> <LBRACE>
    decl_list()
    statement_block()
  <RBRACE>
}

void statement_block() : {}//(12)
{
  (statement() statement_block())
}

/*<ID> <ASSIGN> expression() <SEMIC>
| <ID> <LPAREN> arg_list() <RPAREN> <SEMIC>*/
void statement() : {}//(13)
{
  <ID> statement2()
  | <LBRACE> statement_block() <RBRACE>
  | <IF> condition()
    <LBRACE> statement_block() <RBRACE>
    <ELSE>
    <LBRACE> statement_block() <RBRACE>
  | <WHILE> condition()
    <LBRACE> statement_block() <RBRACE>
  | <SKIP_STRING> <SEMIC>
}

void statement2() : {}//(13a)
{
  <ASSIGN> expression() <SEMIC>
  | <LPAREN> arg_list() <RPAREN> <SEMIC>
}
/*
void expression() : {}//(14)
{
  fragment() binary_arith_op() fragment()
  | <LPAREN> expression() <RPAREN> (binary_arith_op() fragment())
  | <ID> <LPAREN> arg_list() <RPAREN> (binary_arith_op() fragment())
  | <ID> (binary_arith_op() fragment())
  <NUMBER> (binary_arith_op() fragment())
}*/

void expression() : {}//(14)
{
  fragment() binary_arith_op() fragment()
  | <LPAREN> expression() <RPAREN> [binary_arith_op() fragment()]
  | <ID> [binary_arith_op() fragment()]
  | <ID> <LPAREN> arg_list() <RPAREN> [binary_arith_op() fragment()]
}

void expression2() : {}//(14a)
{
  <LPAREN> arg_list() <RPAREN> [binary_arith_op() fragment()]
}

void expression3() : {}//(14b)
{
  [binary_arith_op() fragment()]
}

void binary_arith_op() : {}//(15)
{
  <PLUS_SIGN>
  | <MINUS_SIGN>
}

void fragment() : {}//(16)
{
  <ID>
  | <MINUS_SIGN> <ID>
  | <NUMBER>
  | <TRUE>
  | <FALSE>
}

void condition() : {}//(17)
{
  <NEGATION> condition() (<LPAREN> binary_logical_op() <RPAREN> condition())
  | <LPAREN> condition() <RPAREN> (<LPAREN> binary_logical_op() <RPAREN> condition())
  | expression() comp_op() expression() (<LPAREN> binary_logical_op() <RPAREN> condition())
}

void binary_logical_op() : {}//(17a)
{
  <OR>
  | <AND>
}

void comp_op() : {}//(18)
{
  <EQUALTO>
  | <NOTEQUALTO>
  | <LESSTHAN>
  | <LESSTHANEQUALS>
  | <GREATERTHAN>
  | <GREATERTHANEQUALS>
}

void arg_list() : {}//(19)
{
  (nemp_arg_list())
}

void nemp_arg_list() : {}//(20)
{
  <ID> [<COMMA> nemp_arg_list()]
}
