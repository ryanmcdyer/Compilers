/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CCALRyanMcDyer.jj */
/*@egen*///Ryan McDyer
//13431038

options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
                           
               
                 
//  DEBUG_PARSER=true;
}

PARSER_BEGIN(CCAL)

import java.util.*;
import java.io.*;

public class CCAL/*@bgen(jjtree)*/implements CCALTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTCCALState jjtree = new JJTCCALState();

/*@egen*/

  public static Hashtable ST = new Hashtable();

  public static void main(String args[]) throws ParseException {

    CCAL parser;

    if (args.length == 0) {
      System.out.println("Reading from standard input . . .");
      parser = new CCAL(System.in);
    } else if (args.length == 1) {
      try {
        parser = new CCAL(new java.io.FileInputStream(args[0]));

        SimpleNode root = parser.program();

        System.out.println("Abstract Syntax Tree:");
        root.dump(" ");

        System.out.println();

				SCVisitor visitor = new SCVisitor();
        root.jjtAccept(visitor, null);

/*
        System.out.println();
        System.out.println("Program:");
        PrintVisitor pv = new PrintVisitor();
        root.jjtAccept(pv, null);

        System.out.println();
        System.out.println("Type Checking:");
        TypeCheckVisitor tc = new TypeCheckVisitor();
        root.jjtAccept(tc, ST);    */

      } catch (java.io.FileNotFoundException e) {
        System.err.println("File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Usage is one of:");
      System.out.println(" java CCAL");
      System.out.println("OR");
      System.out.println(" java CCAL inputfile");
      return;
    }
  }
}
PARSER_END(CCAL)


/*****************************************
************ TOKEN DEFINITIONS ***********
*****************************************/
TOKEN_MGR_DECLS :
{
  static int commentNesting = 0;
}
SKIP : /*** Ignoring whitespaces ***/
{
  " "
  | "\t"
  | "\n"
  | "\r"
  | "\f"
}
SKIP : // COMMENTS, taken from lth.se
{
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}
SKIP : /* COMMENTS */
{
  <"/*"> { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
  <"/*"> { commentNesting++; }
  | <"*/"> { commentNesting--;
    if (commentNesting == 0)
      SwitchTo(DEFAULT);
  }
  | <~[]>
}
<DEFAULT> SKIP : //The string "SKIP"
{
  <SKIP_STRING>
}

TOKEN : /* Keywords */
{
  < VAR : "var" >
  | < CONST : "const" >
  | < RETURN : "return" >
  | < INTEGER : "integer" >
  | < BOOLEAN : "boolean" >
  | < VOID : "void" >
  | < MAIN : "main" >
  | < IF : "if" >
  | < ELSE : "else" >
  | < TRUE : "true" >
  | < FALSE : "false" >
  | < WHILE : "while" >
  | < SKIP_STRING : "skip" >
}
TOKEN : /* Other reserved tokens*/
{
  < COMMA : "," >
  | < SEMIC : ";" >
  | < COLON : ":" >
  | < LBRACE : "{" >
  | < RBRACE : "}" >
  | < LPAREN : "(" >
  | < RPAREN : ")" >
}
TOKEN : /* Operators */
{
  < ASSIGN : "=" >
  | < PLUS_SIGN : "+" >
  | < MINUS_SIGN : "-" >
  | < NEGATION : "~" >
  | < OR : "||" >
  | < AND : "&&" >
  | < EQUALTO : "==" >
  | < NOTEQUALTO : "!=" >
  | < LESSTHAN : "<" >
  | < LESSTHANEQUALS : "<=" >
  | < GREATERTHAN : ">" >
  | < GREATERTHANEQUALS : ">=" >
}
TOKEN : /* Numbers and IDs */
{
  < NUMBER : <DIGIT>
    | <NONZERO> (<DIGIT>)*
    | <MINUS_SIGN> <DIGIT>
    | <MINUS_SIGN> <NONZERO> (<DIGIT>)* >
  | < #DIGIT : ["0" - "9"] >
  | < #NONZERO : ["1" - "9"] >
  | < ID : (<LETTER>)(<LETTER> | "_" | <DIGIT>)* >
  | < #LETTER : ["a" - "z", "A" - "Z"] >
}
TOKEN : /* Anything else */
{
  < OTHER : ~[] >
}
/***********************************
************ THE GRAMMAR ***********
***********************************/
SimpleNode program()          : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(1)
{/*@bgen(jjtree) Program */
  try {
/*@egen*/
  decl_list() function_list() main() <EOF>/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void decl_list() : {}//(2)
{
  (decl())*
}

void decl() : {}//(3)
{
  (var_decl() | const_decl())
}

void var_decl()           : {/*@bgen(jjtree) Var_decl */
  ASTVar_decl jjtn000 = new ASTVar_decl(JJTVAR_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(4)
{/*@bgen(jjtree) Var_decl */
  try {
/*@egen*/
  <VAR> id()<COLON>type() <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void const_decl()             : {/*@bgen(jjtree) Const_decl */
  ASTConst_decl jjtn000 = new ASTConst_decl(JJTCONST_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(5)
{/*@bgen(jjtree) Const_decl */
  try {
/*@egen*/
  <CONST> id()<COLON>type() <ASSIGN> expression() <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function_list()              : {/*@bgen(jjtree) FunctionList */
  ASTFunctionList jjtn000 = new ASTFunctionList(JJTFUNCTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(6)
{/*@bgen(jjtree) FunctionList */
  try {
/*@egen*/
  (function_decl())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function_decl()            : {/*@bgen(jjtree) Func_decl */
  ASTFunc_decl jjtn000 = new ASTFunc_decl(JJTFUNC_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(7)
{/*@bgen(jjtree) Func_decl */
  try {
/*@egen*/
  type() id() <LPAREN> param_list() <RPAREN>
  function_body()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function_body()            : {/*@bgen(jjtree) Func_body */
  ASTFunc_body jjtn000 = new ASTFunc_body(JJTFUNC_BODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(7a)
{/*@bgen(jjtree) Func_body */
  try {
/*@egen*/
  <LBRACE>
    decl_list()
    statement_block()
    <RETURN> <LPAREN> [expression()] <RPAREN> <SEMIC>
  <RBRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void type()       : {/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(8)
{/*@bgen(jjtree) Type */
  try {
/*@egen*/
  <INTEGER>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ { jjtn000.value = token; }
  | <BOOLEAN>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.value = token; }
  | <VOID>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { jjtn000.value = token; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*void parameter_list() : {}//(9)
{
  (nemp_parameter_list())*
}

void nemp_parameter_list() #Param : {}//(10)
{
  id()<COLON>type() [<COMMA> nemp_parameter_list()]
}*/

void param_list()           : {/*@bgen(jjtree) ParamList */
  ASTParamList jjtn000 = new ASTParamList(JJTPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(9)
{/*@bgen(jjtree) ParamList */
  try {
/*@egen*/
  (id()<COLON>type() (<COMMA> id()<COLON>type())*)
  |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void main()       : {/*@bgen(jjtree) Main */
  ASTMain jjtn000 = new ASTMain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(11)
{/*@bgen(jjtree) Main */
  try {
/*@egen*/
  <MAIN> <LBRACE>
    decl_list()
    statement_block()
  <RBRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement_block() : {}//(12)
{
  [statement() statement_block()]
}

void statement()  : {}//(13)
{
  LOOKAHEAD(2)
  assignment()
  | functionCall() <SEMIC>
  | <LBRACE> statement_block() <RBRACE>
  | <IF> condition()
    <LBRACE> statement_block() <RBRACE>
    <ELSE>
    <LBRACE> statement_block()/*@bgen(jjtree) IfCond */
                               {
                                 ASTIfCond jjtn001 = new ASTIfCond(JJTIFCOND);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
                               }
                               try {
/*@egen*/ <RBRACE>/*@bgen(jjtree)*/
                               } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001, true);
                                 }
                               }
/*@egen*/        
  | <WHILE> condition()
    <LBRACE> statement_block()/*@bgen(jjtree) WhileCond */
                               {
                                 ASTWhileCond jjtn002 = new ASTWhileCond(JJTWHILECOND);
                                 boolean jjtc002 = true;
                                 jjtree.openNodeScope(jjtn002);
                               }
                               try {
/*@egen*/ <RBRACE>/*@bgen(jjtree)*/
                               } finally {
                                 if (jjtc002) {
                                   jjtree.closeNodeScope(jjtn002, true);
                                 }
                               }
/*@egen*/           
  | <SKIP_STRING> <SEMIC>
}

void assignment()             : {/*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} //(13a)
{/*@bgen(jjtree) Assignment */
  try {
/*@egen*/
  id() <ASSIGN> expression() <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void functionCall()               : {/*@bgen(jjtree) FunctionCall */
  ASTFunctionCall jjtn000 = new ASTFunctionCall(JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} //(13b)
{/*@bgen(jjtree) FunctionCall */
  try {
/*@egen*/
  id() <LPAREN> arg_list() <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void expression() : {}//(14)
{
  LOOKAHEAD(3)
  functionCall() (optional_expression_bin_op())?
  | fragment() (optional_expression_bin_op())?
  | <LPAREN> expression() <RPAREN> (optional_expression_bin_op())?
}

void optional_expression_bin_op() : {}//(14a)
{
    binary_arith_op()
}

void binary_arith_op() : {}//(15)
{
  /*<PLUS_SIGN> { jjtThis.value = token; }
  | <MINUS_SIGN> { jjtThis.value = token; }*/
  <PLUS_SIGN> fragment()/*@bgen(jjtree) #AddOperation( 2) */
                         {
                           ASTAddOperation jjtn001 = new ASTAddOperation(JJTADDOPERATION);
                           boolean jjtc001 = true;
                           jjtree.openNodeScope(jjtn001);
                         }
                         try {
/*@egen*//*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn001,  2);
                           jjtc001 = false;
                         }
/*@egen*/ { jjtn001.value = new Token(PLUS_SIGN, tokenImage[PLUS_SIGN]); }/*@bgen(jjtree)*/
                         } finally {
                           if (jjtc001) {
                             jjtree.closeNodeScope(jjtn001,  2);
                           }
                         }
/*@egen*/                 
  | <MINUS_SIGN> fragment()/*@bgen(jjtree) #SubOperation( 2) */
                            {
                              ASTSubOperation jjtn002 = new ASTSubOperation(JJTSUBOPERATION);
                              boolean jjtc002 = true;
                              jjtree.openNodeScope(jjtn002);
                            }
                            try {
/*@egen*//*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn002,  2);
                              jjtc002 = false;
                            }
/*@egen*/ { jjtn002.value = new Token(MINUS_SIGN, tokenImage[MINUS_SIGN]); }/*@bgen(jjtree)*/
                            } finally {
                              if (jjtc002) {
                                jjtree.closeNodeScope(jjtn002,  2);
                              }
                            }
/*@egen*/                 
}

void fragment() : {}//(16)
{
  id()
  | <MINUS_SIGN> id()
  | number()
  | booleanValue()
}

void id()     : {/*@bgen(jjtree) Id */
                  ASTId jjtn000 = new ASTId(JJTID);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } //(16a)
{/*@bgen(jjtree) Id */
  try {
/*@egen*/
  t = <ID>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { jjtn000.value = token; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void number()         : {/*@bgen(jjtree) Number */
                          ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } //(16b)
{/*@bgen(jjtree) Number */
  try {
/*@egen*/
  t = <NUMBER>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { jjtn000.value = token; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void booleanValue()          : {/*@bgen(jjtree) Boolean */
  ASTBoolean jjtn000 = new ASTBoolean(JJTBOOLEAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} //(16c)
{/*@bgen(jjtree) Boolean */
  try {
/*@egen*/
  <TRUE>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/ { jjtn000.value = token; }
  | <FALSE>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ { jjtn000.value = token; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void condition() : {}//(17)
{
  <NEGATION> condition() optional_condition_bin_op()
  | LOOKAHEAD(3)
    <LPAREN> condition() <RPAREN> optional_condition_bin_op()
  | expression() comp_op() optional_condition_bin_op()
}

void optional_condition_bin_op() : {}//(17a)
{
  (LOOKAHEAD(2)
    binary_logical_op())?
}

void binary_logical_op()          : {/*@bgen(jjtree) Logic_Op */
  ASTLogic_Op jjtn000 = new ASTLogic_Op(JJTLOGIC_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(17b)
{/*@bgen(jjtree) Logic_Op */
  try {
/*@egen*/
  <OR> condition()/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ { jjtn000.value = token; }
  | <AND> condition()/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ { jjtn000.value = token; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void comp_op()             : {/*@bgen(jjtree) Compare_Op */
  ASTCompare_Op jjtn000 = new ASTCompare_Op(JJTCOMPARE_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(18)
{/*@bgen(jjtree) Compare_Op */
  try {
/*@egen*/
  <EQUALTO> expression()/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { jjtn000.value = token; }
  | <NOTEQUALTO> expression()/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ { jjtn000.value = token; }
  | <LESSTHAN> expression()/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/ { jjtn000.value = token; }
  | <LESSTHANEQUALS> expression()/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/ { jjtn000.value = token; }
  | <GREATERTHAN> expression()/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ { jjtn000.value = token; }
  | <GREATERTHANEQUALS> expression()/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/ { jjtn000.value = token; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void arg_list()         : {/*@bgen(jjtree) ArgList */
  ASTArgList jjtn000 = new ASTArgList(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(19)
{/*@bgen(jjtree) ArgList */
  try {
/*@egen*/
  (id() (<COMMA> id())*)
  |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
