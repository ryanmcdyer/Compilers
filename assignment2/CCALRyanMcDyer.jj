/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CCALRyanMcDyer.jj */
/*@egen*///Ryan McDyer
//13431038

options {
  JAVA_UNICODE_ESCAPE = true;
  IGNORE_CASE = true;
               
                 
}

PARSER_BEGIN(CCAL)

import java.util.*;
import java.io.*;

public class CCAL/*@bgen(jjtree)*/implements CCALTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTCCALState jjtree = new JJTCCALState();

/*@egen*/

  public static Hashtable ST = new Hashtable();

  public static void main(String args[]) throws ParseException {
    CCAL parser;
    if (args.length == 0) {
      System.out.println("Reading from standard input . . .");
      parser = new CCAL(System.in);
    } else if (args.length == 1) {
      try {
        parser = new CCAL(new java.io.FileInputStream(args[0]));
        SimpleNode root = parser.program();
        root.dump(" ");

        Enumeration t = ST.keys();

         while ( t.hasMoreElements()  ) {

              temp = (String)t.nextElement();
              temp2 = (STC)ST.get(temp);
              System.out.println(temp);
              if ( temp2.type != null )
                System.out.println(" type = " + temp2.type);
              if ( temp2.value != null )
                System.out.println(" value = " + temp2.value);

        }

      } catch (java.io.FileNotFoundException e) {
        System.err.println("File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("CCAL Parser: Usage is one of:");
      System.out.println(" java CCAL < inputfile");
      System.out.println("OR");
      System.out.println(" java CCAL inputfile");
      return;
    }
    /*try {
      parser.program();
      System.out.println("CCAL Parser: CCAL program parsed successfully.");
    }
    catch (ParseException e)
    {
      System.out.println(e.getMessage());
      System.out.println("CCAL Parser:  Encountered errors during parse.");
    }*/
  }
}
PARSER_END(CCAL)


/*****************************************
************ TOKEN DEFINITIONS ***********
*****************************************/
TOKEN_MGR_DECLS :
{
  static int commentNesting = 0;
  static int lineNumber = 0;
}
SKIP : /*** Ignoring whitespaces ***/
{
  " "
  | "\t"
  | "\n"
  | "\r"
  | "\f"
}
SKIP : // COMMENTS, taken from lth.se
{
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") > //{ lineNumber++; }
}
SKIP : /* COMMENTS */
{
  <"/*"> { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
  <"/*"> { commentNesting++; }
  | <"*/"> { commentNesting--;
    if (commentNesting == 0)
      SwitchTo(DEFAULT);
  }
  | <~[]>
}
<DEFAULT> SKIP : //The string "SKIP"
{
  <SKIP_STRING>
}

TOKEN : /* Keywords */
{
  < VAR : "var" >
  | < CONST : "const" >
  | < RETURN : "return" >
  | < INTEGER : "integer" >
  | < BOOLEAN : "boolean" >
  | < VOID : "void" >
  | < MAIN : "main" >
  | < IF : "if" >
  | < ELSE : "else" >
  | < TRUE : "true" >
  | < FALSE : "false" >
  | < WHILE : "while" >
  | < SKIP_STRING : "skip" >
}
TOKEN : /* Other reserved tokens*/
{
  < COMMA : "," >
  | < SEMIC : ";" >
  | < COLON : ":" >
  | < LBRACE : "{" >
  | < RBRACE : "}" >
  | < LPAREN : "(" >
  | < RPAREN : ")" >
}
TOKEN : /* Operators */
{
  < ASSIGN : "=" >
  | < PLUS_SIGN : "+" >
  | < MINUS_SIGN : "-" >
  | < NEGATION : "~" >
  | < OR : "||" >
  | < AND : "&&" >
  | < EQUALTO : "==" >
  | < NOTEQUALTO : "!=" >
  | < LESSTHAN : "<" >
  | < LESSTHANEQUALS : "<=" >
  | < GREATERTHAN : ">" >
  | < GREATERTHANEQUALS : ">=" >
}
TOKEN : /* Numbers and IDs */
{
  < NUMBER : <DIGIT>
    | <NONZERO> (<DIGIT>)*
    | <MINUS_SIGN> <DIGIT>
    | <MINUS_SIGN> <NONZERO> (<DIGIT>)* >
  | < #DIGIT : ["0" - "9"] >
  | < #NONZERO : ["1" - "9"] >
  | < ID : (<LETTER>)(<LETTER> | "_" | <DIGIT>)* >
  | < #LETTER : ["a" - "z", "A" - "Z"] >
}
TOKEN : /* Anything else */
{
  < OTHER : ~[] >
}
/***********************************
************ THE GRAMMAR ***********
***********************************/
SimpleNode program()          : {/*@bgen(jjtree) PROGRAM */
  ASTPROGRAM jjtn000 = new ASTPROGRAM(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(1)
{/*@bgen(jjtree) PROGRAM */
  try {
/*@egen*/
  decl_list() function_list() main() <EOF>/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void decl_list() : {/*@bgen(jjtree) decl_list */
  ASTdecl_list jjtn000 = new ASTdecl_list(JJTDECL_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(2)
{/*@bgen(jjtree) decl_list */
  try {
/*@egen*/
  (decl())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void decl() : {/*@bgen(jjtree) decl */
  ASTdecl jjtn000 = new ASTdecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(3)
{/*@bgen(jjtree) decl */
  try {
/*@egen*/
  (var_decl() | const_decl()) <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void var_decl()      : {/*@bgen(jjtree) VAR */
  ASTVAR jjtn000 = new ASTVAR(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(4)
{/*@bgen(jjtree) VAR */
  try {
/*@egen*/
  <VAR> <ID><COLON>type()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void const_decl()        : {/*@bgen(jjtree) CONST */
  ASTCONST jjtn000 = new ASTCONST(JJTCONST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(5)
{/*@bgen(jjtree) CONST */
  try {
/*@egen*/
  <CONST> <ID><COLON>type() <ASSIGN> expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function_list() : {/*@bgen(jjtree) function_list */
  ASTfunction_list jjtn000 = new ASTfunction_list(JJTFUNCTION_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(6)
{/*@bgen(jjtree) function_list */
  try {
/*@egen*/
  (function())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function()           : {/*@bgen(jjtree) FUNCTION */
  ASTFUNCTION jjtn000 = new ASTFUNCTION(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(7)
{/*@bgen(jjtree) FUNCTION */
  try {
/*@egen*/
  type() <ID> <LPAREN> parameter_list() <RPAREN>
  <LBRACE>
    decl_list()
    statement_block()
    <RETURN> <LPAREN> [expression()] <RPAREN> <SEMIC>
  <RBRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void type()       : {/*@bgen(jjtree) TYPE */
  ASTTYPE jjtn000 = new ASTTYPE(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(8)
{/*@bgen(jjtree) TYPE */
  try {
/*@egen*/
  <INTEGER>
  | <BOOLEAN>
  | <VOID>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void parameter_list() : {/*@bgen(jjtree) parameter_list */
  ASTparameter_list jjtn000 = new ASTparameter_list(JJTPARAMETER_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(9)
{/*@bgen(jjtree) parameter_list */
  try {
/*@egen*/
  (nemp_parameter_list())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nemp_parameter_list() : {/*@bgen(jjtree) nemp_parameter_list */
  ASTnemp_parameter_list jjtn000 = new ASTnemp_parameter_list(JJTNEMP_PARAMETER_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(10)
{/*@bgen(jjtree) nemp_parameter_list */
  try {
/*@egen*/
  <ID><COLON>type() [<COMMA> nemp_parameter_list()]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void main()       : {/*@bgen(jjtree) MAIN */
  ASTMAIN jjtn000 = new ASTMAIN(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(11)
{/*@bgen(jjtree) MAIN */
  try {
/*@egen*/
  <MAIN> <LBRACE>
    decl_list()
    statement_block()
  <RBRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement_block() : {/*@bgen(jjtree) statement_block */
  ASTstatement_block jjtn000 = new ASTstatement_block(JJTSTATEMENT_BLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(12)
{/*@bgen(jjtree) statement_block */
  try {
/*@egen*/
  [statement() statement_block()]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement()            : {/*@bgen(jjtree) STATEMENT */
  ASTSTATEMENT jjtn000 = new ASTSTATEMENT(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(13)
{/*@bgen(jjtree) STATEMENT */
  try {
/*@egen*/
  <ID> statement2()
  | <LBRACE> statement_block() <RBRACE>
  | <IF> condition()
    <LBRACE> statement_block() <RBRACE>
    <ELSE>
    <LBRACE> statement_block() <RBRACE>
  | <WHILE> condition()
    <LBRACE> statement_block() <RBRACE>
  | <SKIP_STRING> <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement2() : {/*@bgen(jjtree) statement2 */
  ASTstatement2 jjtn000 = new ASTstatement2(JJTSTATEMENT2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(13a)
{/*@bgen(jjtree) statement2 */
  try {
/*@egen*/
  <ASSIGN> expression() <SEMIC>
  | <LPAREN> arg_list() <RPAREN> <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void expression() : {/*@bgen(jjtree) expression */
  ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(14)
{/*@bgen(jjtree) expression */
  try {
/*@egen*/
  LOOKAHEAD(2)
  <ID> <LPAREN> arg_list() <RPAREN> optional_expression_bin_op()
  | fragment() optional_expression_bin_op()
  | <LPAREN> expression() <RPAREN> optional_expression_bin_op()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void optional_expression_bin_op() : {/*@bgen(jjtree) optional_expression_bin_op */
  ASToptional_expression_bin_op jjtn000 = new ASToptional_expression_bin_op(JJTOPTIONAL_EXPRESSION_BIN_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(14a)
{/*@bgen(jjtree) optional_expression_bin_op */
    try {
/*@egen*/
    (binary_arith_op() fragment())?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void binary_arith_op() : {/*@bgen(jjtree) binary_arith_op */
  ASTbinary_arith_op jjtn000 = new ASTbinary_arith_op(JJTBINARY_ARITH_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(15)
{/*@bgen(jjtree) binary_arith_op */
  try {
/*@egen*/
  <PLUS_SIGN>
  | <MINUS_SIGN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void fragment() : {/*@bgen(jjtree) fragment */
  ASTfragment jjtn000 = new ASTfragment(JJTFRAGMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(16)
{/*@bgen(jjtree) fragment */
  try {
/*@egen*/
  <ID>
  | <MINUS_SIGN> <ID>
  | <NUMBER>
  | <TRUE>
  | <FALSE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void condition() : {/*@bgen(jjtree) condition */
  ASTcondition jjtn000 = new ASTcondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(17)
{/*@bgen(jjtree) condition */
  try {
/*@egen*/
  <NEGATION> condition() optional_condition_bin_op()
  | LOOKAHEAD(3)
    <LPAREN> condition() <RPAREN> optional_condition_bin_op()
  | expression() comp_op() expression() optional_condition_bin_op()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void optional_condition_bin_op() : {/*@bgen(jjtree) optional_condition_bin_op */
  ASToptional_condition_bin_op jjtn000 = new ASToptional_condition_bin_op(JJTOPTIONAL_CONDITION_BIN_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(17a)
{/*@bgen(jjtree) optional_condition_bin_op */
  try {
/*@egen*/
  (LOOKAHEAD(2)
    binary_logical_op() condition())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void binary_logical_op() : {/*@bgen(jjtree) binary_logical_op */
  ASTbinary_logical_op jjtn000 = new ASTbinary_logical_op(JJTBINARY_LOGICAL_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(17b)
{/*@bgen(jjtree) binary_logical_op */
  try {
/*@egen*/
  <OR>
  | <AND>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void comp_op() : {/*@bgen(jjtree) comp_op */
  ASTcomp_op jjtn000 = new ASTcomp_op(JJTCOMP_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(18)
{/*@bgen(jjtree) comp_op */
  try {
/*@egen*/
  <EQUALTO>
  | <NOTEQUALTO>
  | <LESSTHAN>
  | <LESSTHANEQUALS>
  | <GREATERTHAN>
  | <GREATERTHANEQUALS>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void arg_list() : {/*@bgen(jjtree) arg_list */
  ASTarg_list jjtn000 = new ASTarg_list(JJTARG_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(19)
{/*@bgen(jjtree) arg_list */
  try {
/*@egen*/
  (nemp_arg_list())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nemp_arg_list() : {/*@bgen(jjtree) nemp_arg_list */
  ASTnemp_arg_list jjtn000 = new ASTnemp_arg_list(JJTNEMP_ARG_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}//(20)
{/*@bgen(jjtree) nemp_arg_list */
  try {
/*@egen*/
  <ID> [<COMMA> nemp_arg_list()]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
