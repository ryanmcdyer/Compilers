/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. BasicL.jj */
/*@egen*//*******************************
***** SECTION 1 - OPTIONS *****
*******************************/

options { 
	JAVA_UNICODE_ESCAPE = true; 
	             
	               
	                       
}

/*********************************
***** SECTION 2 - USER CODE *****
*********************************/

PARSER_BEGIN(BasicL)

import java.io.*;
import java.util.*;

public class BasicL/*@bgen(jjtree)*/implements BasicLTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTBasicLState jjtree = new JJTBasicLState();

/*@egen*/
	public static Hashtable ST = new Hashtable();
	public static void main(String args[]) throws ParseException, FileNotFoundException
	{

		String temp;
		String temp2;

		if (args.length < 1)
    {
      System.out.println("Please pass in the filename.");
      System.exit(1);
    }

		BasicL parser = new BasicL(new FileInputStream(args[0]));

    ASTProgram root = parser.Program();

    System.out.println("Abstract Syntax Tree:");

    root.dump(" ");
    System.out.println("\n\n------Symantic Analysis------\n");
    STVisitor stv = new STVisitor();
    root.jjtAccept(stv,null);
	}
}

PARSER_END(BasicL)

/****************************************
***** SECTION 3 - TOKEN DEFINITIONS *****
****************************************/

TOKEN_MGR_DECLS :
{
	static int commentNesting = 0;
}

SKIP : /* COMMENTS */
{
		<"--" (["a" - "z"] | ["A" - "Z"] | ["0" - "9"] | " ")* ("\n" | "\r" |"\r\n")>
	|	"/*" { commentNesting++; } : IN_COMMENT
	
}

<IN_COMMENT> SKIP :
{
		"/*" { commentNesting++; }
	| "*/" { commentNesting--;
			if (commentNesting == 0)
				SwitchTo(DEFAULT);
			}
	| <~[]>
}

SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
		" "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}

TOKEN : /* Keywords */ 
{
		<AND : "and">
	|	<BOOL : "bool">
	|	<CONST : "const">
	|	<DO : "do">
	|	<ELSE : "else">
	|	<FALSE : "false">
	|	<IF : "if">
	|	<INT : "int">
	| <DOUBLE: "double">
	| <MAIN : "main">
	|	<NOT : "not">
	| <OR : "or">
	|	<RETURN : "return">
	| <THEN : "then">
	|	<TRUE : "true">
	| <VAR : "var">
	| <VOID : "void">
	| <WHILE : "while">
	|	<BEGIN : "begin">
	| <END : "end">
}

 TOKEN : /* Identifiers */
 {
		<ID : <CHAR> (<DIGIT> | <CHAR> | "_" )* >
 	|	<#CHAR : ["a" - "z"] | ["A" - "Z"]>
 }

TOKEN : /* Numbers */
{
		<NUM : (<DIGIT>)+>
	|	<REAL: ( (<DIGIT>)+ "." (<DIGIT>)*) | ((<DIGIT>)* "." (<DIGIT>)+) >
	|	<#DIGIT : ["0" - "9"]>
}

TOKEN : /* Operators and Relations */
{
		<PLUS_SIGN : "+">
	|	<MINUS_SIGN : "-">
	|	<MULT_SIGN : "*">
	|	<DIV_SIGN : "/">
	|	<EQUALS_SIGN : "=">
	| <NOT_EQUALS_SIGN : "!=">
	|	<LESS_THAN : "<">
	| <GREATER_THAN : ">">
	|	<LESS_THAT_EQUALS : "<=">
	| <GREATER_THAN_EQUALS : ">=">
	|	<LEFT_BRACKET : "(">
	|	<RIGHT_BRACKET : ")">
	|	<COMMA : ",">
	|	<SEMICOLON : ";">
	|	<TYPE_ASSIGN : ":">
	|	<ASSIGN : ":=">
}

TOKEN : /* Anything not recognised so far */
{
	< OTHER : ~[] >
}

/***********************************
***** SECTION 4 - THE GRAMMAR *****
***********************************/

ASTProgram Program()          : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
        try {
/*@egen*/
	( Decl() )* // fix due to it decl already being declared one or more times no need to re-declare one or more (*)
	( Function_Decl() )*
	Main_Prog()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Decl() : {}
{
	(
	 	Var_decl() 
	) 
	| (
			Const_decl()
		)
}

void Var_decl()      : {/*@bgen(jjtree) Decl */
  ASTDecl jjtn000 = new ASTDecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Decl */
        try {
/*@egen*/
	(	<VAR> Ident_list() <TYPE_ASSIGN> Type() ( <COMMA> Ident_list() <TYPE_ASSIGN> Type() )* ) <SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Const_decl()            : {/*@bgen(jjtree) ConstDecl */
  ASTConstDecl jjtn000 = new ASTConstDecl(JJTCONSTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstDecl */
        try {
/*@egen*/
	( <CONST> Indentifier() <TYPE_ASSIGN> Type() <EQUALS_SIGN> Expression() ( <COMMA> Indentifier() <TYPE_ASSIGN> Type() <EQUALS_SIGN> Expression() )* <SEMICOLON>)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Function_Decl()                : {/*@bgen(jjtree) Function_Decl */
  ASTFunction_Decl jjtn000 = new ASTFunction_Decl(JJTFUNCTION_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Function_Decl */
        try {
/*@egen*/
	( Type() Indentifier() <LEFT_BRACKET> Param_list() <RIGHT_BRACKET> )
	( Function() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Function()               	 : {/*@bgen(jjtree) Function_body */
  ASTFunction_body jjtn000 = new ASTFunction_body(JJTFUNCTION_BODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Function_body */
        try {
/*@egen*/
	<BEGIN>
	( Decl() )* 
	( Statment() <SEMICOLON> ) *
	(<RETURN> ( Expression() | {} ) <SEMICOLON>)
	<END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Param_list() : {}
{/*@bgen(jjtree) #Params(> 1) */
        {
          ASTParams jjtn001 = new ASTParams(JJTPARAMS);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		Indentifier() <TYPE_ASSIGN> Type() ( <COMMA> Indentifier() <TYPE_ASSIGN> Type() )* 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/            
	| {}
}

void Type()       : {/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
	<INT>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/  { jjtn000.value = token;} 
	| <DOUBLE>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ { jjtn000.value = token;} 
	| <BOOL>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.value = token;} 
	|	<VOID>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Main_Prog()       : {/*@bgen(jjtree) Main */
  ASTMain jjtn000 = new ASTMain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Main */
        try {
/*@egen*/
	<MAIN>
	<BEGIN>
	( Decl() )*
	( Statment() <SEMICOLON>)*
	<END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Statment() : {}
{/*@bgen(jjtree) #Assign( 2) */
                {
                  ASTAssign jjtn001 = new ASTAssign(JJTASSIGN);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(	
			Indentifier() (<ASSIGN> Expression() | FunctionCall() ) 
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
                }
/*@egen*/           	
	|	<BEGIN> ( Statment() <SEMICOLON> )* <END>
	|	(
			<IF> Condition() <THEN> Statment() <SEMICOLON> <ELSE> Statment()
		)    
	|	(
			<WHILE> Condition() <DO> Statment()
		) 	
	| {} // this will allow you to just stick aload of semicolons in the file and will parse correctly !!!
}


//fixed expression to allow for the function call in condition to work properly!
void Expression() : {}
{
	LOOKAHEAD(2)
	FunctionCall()
	| AddExpression()
}

void AddExpression() : {}
{/*@bgen(jjtree) #Add(> 1) */
        {
          ASTAdd jjtn001 = new ASTAdd(JJTADD);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		MultExpression() ( AddOp() MultExpression() )*
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/         
}

void MultExpression() : {}
{/*@bgen(jjtree) #Mult(> 1) */
        {
          ASTMult jjtn001 = new ASTMult(JJTMULT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(
		Fragment() ( MultOp() Fragment() )*
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/          
}

void AddOp()        : {/*@bgen(jjtree) AddOp */
  ASTAddOp jjtn000 = new ASTAddOp(JJTADDOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AddOp */
                try {
/*@egen*/
		<PLUS_SIGN>/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/ { jjtn000.value = token;} 
	| <MINUS_SIGN>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/ 
}

void MultOp()         : {/*@bgen(jjtree) MultOp */
  ASTMultOp jjtn000 = new ASTMultOp(JJTMULTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultOp */
                try {
/*@egen*/
		<MULT_SIGN>/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/ { jjtn000.value = token;} 
	| <DIV_SIGN>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/ 
}

void Fragment() : {}
{
		Indentifier() //[ Args_list() ] -- removed as reults in mult node for function calls
	|	Bool()	
	|	Number()
	| Real()
	| <LEFT_BRACKET> Expression() <RIGHT_BRACKET>
}

void BoolOpp()          : {/*@bgen(jjtree) BoolOpp */
  ASTBoolOpp jjtn000 = new ASTBoolOpp(JJTBOOLOPP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BoolOpp */
        try {
/*@egen*/
	(
			<EQUALS_SIGN>/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/ { jjtn000.value = token;} 
		| <NOT_EQUALS_SIGN>/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
                                    }
/*@egen*/ { jjtn000.value = token;} 
		| <LESS_THAN>/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ { jjtn000.value = token;} 
		| <GREATER_THAN>/*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn000, true);
                                   jjtc000 = false;
                                 }
/*@egen*/ { jjtn000.value = token;} 
		| <GREATER_THAN_EQUALS>/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/ { jjtn000.value = token;} 
		| <LESS_THAT_EQUALS>/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/ { jjtn000.value = token;} 
		| <AND>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { jjtn000.value = token;} 
		| <OR>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { jjtn000.value = token;} 
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}


void Condition() : {}
{
		<NOT> Condition()
	|/*@bgen(jjtree) #Condition(> 0) */
          {
            ASTCondition jjtn001 = new ASTCondition(JJTCONDITION);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ (
		 [<LEFT_BRACKET>] Expression() ( ( BoolOpp() ) Expression()  [<RIGHT_BRACKET>] ) *
		)/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 0);
            }
          }
/*@egen*/               
}

void Ident_list()             : {/*@bgen(jjtree) Ident_list */
  ASTIdent_list jjtn000 = new ASTIdent_list(JJTIDENT_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Ident_list */
        try {
/*@egen*/
	Indentifier() ( <COMMA> Indentifier() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Arg_list()           : {/*@bgen(jjtree) Arg_list */
  ASTArg_list jjtn000 = new ASTArg_list(JJTARG_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Arg_list */
        try {
/*@egen*/
	<LEFT_BRACKET> (Indentifier() ( <COMMA> Indentifier())*  | {}) <RIGHT_BRACKET>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Indentifier()     : {/*@bgen(jjtree) Id */
                           ASTId jjtn000 = new ASTId(JJTID);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Id */
        try {
/*@egen*/
	<ID>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Number()      : {/*@bgen(jjtree) Num */
                       ASTNum jjtn000 = new ASTNum(JJTNUM);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Num */
        try {
/*@egen*/
	<NUM>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		 jjtn000.value = token; 
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Bool()       : {/*@bgen(jjtree) Bool */
  ASTBool jjtn000 = new ASTBool(JJTBOOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bool */
        try {
/*@egen*/
	<TRUE>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/{ jjtn000.value = token;} 
	| <FALSE>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Real()       : {/*@bgen(jjtree) Real */
                      ASTReal jjtn000 = new ASTReal(JJTREAL);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) Real */
        try {
/*@egen*/
	<REAL>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void FunctionCall()               : {/*@bgen(jjtree) FunctionCall */
  ASTFunctionCall jjtn000 = new ASTFunctionCall(JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionCall */
        try {
/*@egen*/
	Indentifier() Arg_list()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}